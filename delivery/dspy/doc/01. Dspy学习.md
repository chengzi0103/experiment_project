---
tags:
  - Dspy
  - 安装
  - 学习
Create Time: 2024-04-30T09:06:00
Update Time: "{{date}},{{time}}"
Title: Dspy学习
---
# 1, DSPy 简介

### 1.1 当前大语言模型使用存在的问题

在管道中多次使用LM时，通常面临以下挑战：

1. **问题分解**：将复杂问题分解为多个步骤。
2. **提示编写**：为每个步骤编写和优化提示，确保其单独运行良好。
3. **步骤整合**：调整各个步骤以确保它们协同工作。
4. **示例生成**：生成合成示例来测试和调整每个步骤。
5. **微调成本**：使用这些示例微调较小的LM以降低成本。

这种方法既复杂又混乱：每次更改管道、LM或数据时，所有提示（或微调步骤）都可能需要重新调整。



## 1.2 为什么使用 DSPy？

DSPy 是一个用于算法优化语言模型（LM）提示和权重的框架。简单来说，DSPy 可以优化提示，使得我们不再需要花费大量时间在提示工程（prompt engineering）和提示调优（prompt tuning）上。它能够使强大的模型（如 GPT-3.5 或 GPT-4）和本地模型（如 T5-base 或 Llama2-13b）在任务上更加可靠。

## 1.3 Dspy主要模块和功能？



### 1.3.1 Signatures (签名)
**Signatures** 模块用于抽象化提示。它主要关注于如何定义和使用提示，以便在不同的上下文中能够灵活应用。这一模块的主要功能包括：
- 提供一种标准化的方法来创建提示。
- 允许用户定义自定义提示格式。
- 支持提示的复用和共享。

### 1.3.2 Modules (模块)
**Modules** 模块用于抽象化提示技术。它主要涉及如何将不同的提示技术进行模块化，使得这些技术可以独立开发和测试。这一模块的主要功能包括：
- 提供各种提示技术的实现。
- 允许用户组合和定制不同的提示技术。
- 支持提示技术的扩展和优化。

### 1.3.3 Optimizers (优化器)
**Optimizers** 模块可以调优模块的提示（或权重）。它主要用于优化提示的效果，使得提示能够更高效地完成任务。这一模块的主要功能包括：
- 提供多种优化算法。
- 允许用户调整提示的权重和参数。
- 支持自动化的提示调优过程。

这些模块和功能共同构成了 DSPy 的核心组件，帮助用户更好地创建和优化提示系统。
# 2, 模块说明
## 2.1 Signature (签名)模块说明

### 什么是 Signature?
在典型的 LLM（大型语言模型）管道中，有两个关键组件：LLM 和提示。在 DSPy 中，我们在任何 DSPy 脚本的开头配置 LLM，并通过 **Signatures** 定义提示。Signature 通常由两个基本组件组成：**输入字段** 和 **输出字段**。你还可以传递一个指令来定义任务的更强大需求。

**两种编写 `Signature` 的方法:**

   * **内联方法 (Inline Method):**  简单直接，适合快速定义任务。
      * 格式: `输入字段1, 输入字段2,... -> 输出字段1, 输出字段2,...`
      * 例子:  `question -> answer` 
   * **基于类的方法 (Class-Based Method):**  更强大，可以添加详细的描述和控制。
      * 使用 Python 类来定义 Signature，可以添加描述、前缀等。
      * 例子:
      ```python
      class BasicQA(dspy.Signature):
          """回答问题，答案要简短。"""
          question = dspy.InputField()
          answer = dspy.OutputField(desc="通常是 1 到 5 个词", prefix="问题的答案:") 
          
      ```

**Signature 的作用:**
   * **输入字段 (Input Fields):**  告诉模型你的输入是什么。
   * **输出字段 (Output Fields):**  告诉模型你期望的输出是什么。
**Signature 的优势:**
   * 帮助 LLM 更好地理解你的任务。
   * 确保任务执行的准确性。
   *  使代码更易读，更易维护。
**简单例子:**
   ```python
   # 使用内联方法定义 Signature
   dspy.Predict(question->answer) 
   ```

   这段代码告诉 DSPy，你想要执行一个预测任务，输入是 `question`，输出是 `answer`。

签名的输入字段在 `->` 的左侧声明，输出字段在右侧声明。
~~~
QA Task: question->answer  
RAG Task: context,question->answer,rationale
~~~

## 2.2 Signature (签名)模块案例

**代码**:
```python
import dspy  
  
# 定义 Signatureclass BasicQA(dspy.Signature):  
    """回答问题，答案要简短。"""  
    question = dspy.InputField()  
    answer = dspy.OutputField(desc="通常是 1 到 25 个词", prefix="问题的答案:")  
  
# 创建任务模块  
class QAModule(dspy.Module):  
    def __init__(self):  
        super().__init__()  
        # 使用 BasicQA Signature 定义任务  
        self.qa_task = dspy.Predict(BasicQA)  
  
    def forward(self, question):  
        # 执行任务并返回结果  
        return self.qa_task(question=question)  
  
# 设置语言模型  
  
# 创建 QAModule 实例  
qa_module = QAModule()  
  
# 定义问题  
question = "成都最好吃的食物是什么？"  
  
# 执行任务并获取答案  
response = qa_module.forward(question)  
  
print(response.answer)  # 输出答案，例如 "问题的答案: 珠穆朗玛峰"  
turbo.inspect_history(n=1)  
# 查看历史记录

```

**结果Prompt**:
```
火锅。

回答问题，答案要简短。
---
Follow the following format.

Question: ${question}
问题的答案: 通常是 1 到 25 个词
---

Question: 成都最好吃的食物是什么？
问题的答案: 火锅。
```


## 2.1 Modules (模块)模块说明

1. **什么是 Modules?**

   - Modules 是 DSPy 的核心，你可以把它们想象成乐高积木，每个积木都有特定的功能。
   - 你可以把不同的 Modules 组合起来，搭建出复杂的 AI 应用，就像用乐高积木搭建城堡一样。

2. **Modules 的作用:**

   -  每个 Module 都封装了一种特定的提示技术，例如：
      - `dspy.Predict`:  最基础的预测模块，适合简单的问答、文本生成等任务。
      - `dspy.ChainOfThought`:  让模型像人一样一步一步思考，适合逻辑推理、数学计算等任务。
      - `dspy.ReAct`:  让模型可以跟外部环境互动，例如查询数据库、调用 API 等，适合更复杂的任务。

3. **如何使用 Modules?**

   -  非常简单，只需要三个步骤：
      1. **声明 (Declare):**  告诉 DSPy 你要使用哪个 Module，以及你的任务是什么 (使用 Signature)。
      2. **调用 (Call):**  把你的输入数据 "喂" 给 Module。
      3. **提取 (Extract):**  从 Module 的输出中获取你想要的结果。
    
4. **适用场景**

- 复杂工作流程
- 需要模块化和可重用组件
- 需要持续更新和维护
- 需要强大错误处理
### 2.1.1 DSPy Retrieve 模块:  像搜索引擎一样找到相关信息


1. **Retrieve 模块的作用:**

   -  想象一下你在使用搜索引擎，输入一个问题，然后搜索引擎会返回一些相关的网页链接。
   -  Retrieve 模块就类似于搜索引擎，它可以根据你的问题，从大量的文本数据中找到最相关的段落。

2. **如何使用 Retrieve 模块?**

   -  首先，你需要告诉 DSPy 你要使用哪个 "搜索引擎" (检索模型)，例如 `dspy.ColBERTv2`。
   -  然后，你需要创建一个 `dspy.Retrieve` 对象，并指定要返回多少个结果 (例如 `k=3`)。
   -  最后，你只需要把你的问题 "喂" 给 `Retrieve` 对象，它就会返回最相关的段落。

3. **代码示例:**

   ```python
   import dspy

   # 1. 选择 "搜索引擎":  这里使用 ColBERTv2 模型
   colbert = dspy.ColBERTv2(url='http://20.102.90.50:2017/wiki17_abstracts') 
   dspy.settings.configure(rm=colbert)  # 配置 DSPy 使用这个模型

   # 2. 创建 Retrieve 对象,  指定返回 3 个结果
   retriever = dspy.Retrieve(k=3) 

   # 3.  输入问题，获取答案
   question = "人工智能有哪些应用？"
   results = retriever(question).passages  # 获取相关段落

   # 打印结果
   for i, passage in enumerate(results):
       print(f"{i+1}. {passage}") 
   ```

4. **Retrieve 模块的优点:**

   -  简单易用，只需要几行代码就能实现信息检索功能。
   -  可以与不同的检索模型配合使用，例如 ColBERTv2,  FAISS 等。
   -  可以灵活地配置检索参数，例如返回结果的数量、排序方式等。

**总而言之，Retrieve 模块是 DSPy 中一个非常实用的工具，它可以帮助你快速地从海量文本数据中找到你想要的信息。**


### 2.1.2 DSPy Program of Thought 模块: 让 AI 像程序员一样思考

1. **Program of Thought (PoT) 是什么?**

   -  传统的 AI 模型通常只能进行简单的推理，而 PoT 则可以让 AI 模型像程序员一样，通过编写代码来解决问题。
   -  简单来说，PoT 就是让 AI 模型先把解决问题的思路用代码写出来，然后再运行代码得到最终答案。

2. **PoT 模块的优势:**
   -  **更强大的推理能力:**  通过编写代码，AI 模型可以处理更复杂、更抽象的问题。
   -  **更高的准确性:**  代码的逻辑性更强，可以减少 AI 模型犯错的概率。
   -  **可解释性更强:**  我们可以通过查看 AI 模型生成的代码来理解它的思考过程。

3. **PoT 模块的使用步骤:**

   -  **定义 Signature:**  告诉 DSPy 你的问题是什么，以及你希望 AI 模型生成什么样的代码。
   -  **创建 PoT 对象:**  使用 `dspy.ProgramOfThought(signature)` 创建一个 PoT 对象。
   -  **执行任务:**  把你的问题 "喂" 给 PoT 对象，它就会自动生成代码、运行代码，并返回最终答案。

4. **代码示例:**

   ```python
 import dspy  
  
  
  
# 定义 Signature: 输入是两个字符串表示的数字，输出是它们的和  
class AddTwoNumbers(dspy.Signature):  
    a = dspy.InputField(desc="第一个数字", type=str)  
    b = dspy.InputField(desc="第二个数字", type=str)  
    sum = dspy.OutputField(desc="两个数字的和", type=str)  
  
# 创建 PoT 对象  
pot = dspy.ProgramOfThought(AddTwoNumbers)  
  
# 定义问题，将数字转换为字符串  
problem = {"a": str(10), "b": str(20)}    
  
# 解决问题  
response = pot(**problem)  
  
# 打印结果  
print(response.sum)  # 输出: 30

   ```

**输出结果**
~~~
30
---
A: 10
B: 20
Code:
```python
a = 10
b = 20
sum = a + b
sum
```
Code Output: 30
Reasoning: Let's think step by step in order to produce the sum. We start by assigning the value 10 to variable `a` and the value 20 to variable `b`. Then, we calculate the sum of `a` and `b` by using the addition operator `+`. The result is stored in the variable `sum`. Finally, we output the value of `sum`.
~~~
**结果Prompt**:
```
Given the final code `a`, `b`, `final_generated_code`, `code_output`, provide the final `sum`.\n\n---\n\nFollow the following format.\n\nA: 第一个数字\n\nB: 第二个数字\n\nCode: python code that answers the question\n\nCode Output: output of previously-generated python code\n\nReasoning: Let's think step by step in order to ${produce the sum}. We ...\n\nSum: 两个数字的和\n\n---\n\nA: 10\n\nB: 20\n\nCode:\na = 10\nb = 20\nsum = a + b\nsum\n\nCode Output: <built-in function sum>\n\nReasoning: Let's think step by step in order to"
```

**总而言之，PoT 模块是 DSPy 中一个非常强大的工具，它可以让 AI 模型像程序员一样思考，从而解决更复杂的问题。**


### 2.1.3 Dspy-ReAct 模块

1. **ReAct 的工作原理:**

   - **“思考-行动-观察”循环 (Thought-Action-Observation Loop):**  这是 ReAct 模块的核心机制。它模拟了人类解决问题时的思维过程：
     - **思考 (Thought):**  分析当前情况，思考下一步行动。
     - **行动 (Action):**  执行具体的查询或操作，例如调用搜索引擎、访问数据库等。
     - **观察 (Observation):**  根据行动结果获取反馈，调整下一步思考方向。

   - **迭代式优化:** ReAct 会执行预设次数的循环迭代（默认为 3 次），每次迭代都会根据观察结果更新对任务的理解，从而逐步优化最终输出。

可以设置最大迭代次数、终止条件等参数来控制 ReAct 的行为。

2. **ReAct 模块的优势:**

   - **处理复杂任务:**  相较于简单的预测模型，ReAct 更适合处理需要多步骤推理和信息整合的复杂任务。
   - **可解释性:**  通过观察 ReAct 的历史记录，可以清晰地了解其推理过程和决策依据。
   - **可扩展性:**  用户可以自定义工具集，扩展 ReAct 的能力范围，使其适应不同的任务场景。

**举例说明:**
~~~
import dspy  
  
# 定义一个简单的产品评论情感分析任务的签名  
class ProductReviewSentiment(dspy.Signature):  
    """分析产品评论的情感."""  
    review = dspy.InputField(desc="")  
    sentiment = dspy.OutputField(desc="说明评论的感情")  
  
# 初始化 ReAct 模块，使用 ProductReviewSentiment 签名  
react_module = dspy.ReAct(ProductReviewSentiment)  
  
# 定义一个示例产品评论  
review = "这款手机的相机太棒了！画质清晰，功能强大，我非常喜欢！但是我觉得它的续航不是特别好,用几个小时就需要充电!"  
  
# 使用 ReAct 模块分析评论情感  
result = react_module(review=review)  
  
# 打印结果  
print(f"评论: {review}")  
print(f"情感分析结果: {result.sentiment}")

情感分析结果: positive

~~~

**返回结果Prompt**:
```


```



### 2.1.4 Dspy-ChainOfThought 模块

`ChainOfThought` 是 DSPy 库中的一个模块，旨在通过引导模型逐步推理的方式来解决复杂问题。这种方法模拟了人类的思维过程，即通过一系列逻辑步骤逐步解决问题，而不是直接给出答案。

### 主要特点

1. **逐步推理**：`ChainOfThought` 通过分解复杂问题为一系列简单的逻辑步骤，帮助模型更好地理解和解决问题。
2. **提高准确性**：这种方法可以显著提高模型在复杂任务上的准确性，因为它减少了直接生成答案时可能出现的错误。
3. **通用性**：`ChainOfThought` 可以应用于各种类型的任务，包括数学问题、逻辑推理、文本生成等。

### 使用示例

以下是一个使用 `ChainOfThought` 模块的示例代码：

```python
    class MathQuestion(dspy.Module):    
    def __init__(self):    
        super().__init__()    
        # 使用 ChainOfThought 进行逐步推理    
self.think = dspy.ChainOfThought('question -> answer')    
    def forward(self, question:str):      
        # 组合完整解决方案    
return self.think(question= question)     
    
```

**结果及其逻辑**:
```

Question: 现在笼子里有鸡（雉）和兔子在一起。从上面数一共有三十五个头，从下面数一共有九十四只脚，问一共有多少只鸡、多少只兔子？ 使用中文回答
Reasoning: Let's think step by step in order to Question: 现在笼子里有鸡（雉）和兔子在一起。从上面数一共有三十五个头，从下面数一共有九十四只脚，问一共有多少只鸡、多少只兔子？ 使用中文回答
Reasoning: Let's think step by step in order to 解决这个问题。我们可以使用鸡兔同笼问题的经典解法。设鸡的数量为x，兔子的数量为y。

1. 根据题意，我们知道：
   - 鸡和兔子的总头数为35，即 \( x + y = 35 \)
   - 鸡和兔子的总脚数为94，即 \( 2x + 4y = 94 \)

2. 我们可以通过代数方法来解这个方程组。首先，我们可以简化第二个方程：
   - \( 2x + 4y = 94 \)
   - 两边同时除以2，得到 \( x + 2y = 47 \)

3. 现在我们有两个方程：
   - \( x + y = 35 \)
   - \( x + 2y = 47 \)

4. 用第二个方程减去第一个方程：
   - \( (x + 2y) - (x + y) = 47 - 35 \)
   - \( y = 12 \)

5. 代入 \( y = 12 \) 到第一个方程中：
   - \( x + 12 = 35 \)
   - \( x = 23 \)

Answer: 一共有23只鸡，12只兔子。
```


`ChainOfThought` 是 DSPy 中一个强大的模块，通过引导模型逐步推理的方式，显著提高了模型在复杂任务上的准确性和可靠性。它适用于各种需要逻辑推理和逐步解决问题的场景，是提升语言模型性能的重要工具。




# 3, Dspy-Optimizer 优化器说明

### Optimizer 的作用

Optimizer 的主要任务是通过调整 DSPy 程序的参数（如提示、示例、语言模型权重等），使程序在特定任务上的表现达到最佳。它类似于机器学习中的超参数优化，但针对的是 DSPy 程序的特定结构和参数。

### 优化的内容

- **语言模型权重**：调整语言模型的参数，使其更适合特定任务。
- **提示**：优化提示的内容和结构，以提高模型的输出质量。
- **示例**：选择和生成合适的示例来指导模型的行为。

### 常用的 DSPy Optimizers

1. **LabeledFewShot**：
   - 利用标记的输入输出数据点构建少量示例。

2. **BootstrapFewShot**：
   - 使用教师模块生成完整的示例，并用度量标准验证这些示例。

3. **BootstrapFewShotWithRandomSearch**：
   - 多次应用 BootstrapFewShot 并进行随机搜索，选择最佳程序。

4. **BootstrapFewShotWithOptuna**：
   - 使用 Optuna 优化示例集，最大化评估度量。

5. **KNNFewShot**：
   - 通过 k-近邻算法选择示例，优化训练集。

6. **COPRO**：
   - 生成和优化新指令，使用坐标上升法（爬山算法）。

7. **MIPRO**：
   - 生成指令和少量示例，使用贝叶斯优化搜索生成的指令/示例空间。

8. **BootstrapFinetune**：
   - 将基于提示的 DSPy 程序转化为权重更新（适用于较小的语言模型）。

9. **Ensemble**：
   - 集成多组 DSPy 程序，并将其作为单个程序使用。

### 使用 Optimizer 的步骤

1. **选择合适的 Optimizer**：
   - 根据数据量和任务需求选择合适的优化器。

2. **配置和初始化 Optimizer**：
   - 设置优化器的参数，例如度量标准、最大示例数等。

3. **编译和优化程序**：
   - 使用优化器对程序进行编译和优化，生成优化后的程序。

4. **保存和部署优化后的程序**：
   - 将优化后的程序保存为文件，方便后续使用和部署。


## 3.1 BootstrapFewShot 优化器模块

**打个比方:**

想象你正在教一个小学生学习写作。你手头只有几篇优秀的作文（标注样本）。为了让小学生学习到更多写作技巧，你可以先让他模仿这几篇作文写几篇新的作文（引导样本）。然后，你再将优秀的作文和小学生模仿的作文混合在一起，让他学习和分析，最终提高他的写作水平。

**重点内容讲解：**

1. **BootstrapFewShot 的作用:**

   -  少量样本学习（Few-shot learning）一直是机器学习中的一个难题。
   -  `BootstrapFewShot`  通过一种称为“自举”（Bootstrapping）的技术，利用未标注的数据来扩充训练集，从而提高模型在少量样本情况下的表现。

2. **工作原理:**

   -  **训练“教师”模型:** 首先，使用少量标注数据训练一个基础模型，称为“教师”模型。
   -  **生成“引导”样本:**  利用教师模型对大量未标注数据进行预测，并将预测结果作为新的训练样本，称为“引导”样本。
   -  **训练“学生”模型:**  将标注样本和引导样本混合在一起，训练一个新的模型，称为“学生”模型。由于学生模型能够学习到更多的数据，因此其性能通常优于教师模型。

3. **关键参数:**

   -  `max_labeled_demos`:  用于训练学生模型的最大**标注**样本数量。
   -  `max_bootstrapped_demos`:  通过教师模型生成的**引导**样本数量。

4. **代码示例分析:**

   -  文档中提供了一个基于 GSM8K 数据集的问答任务示例，演示了如何使用 `BootstrapFewShotWithRandomSearch`  来优化模型。
   -  代码中展示了如何配置语言模型、导入数据集、定义问答签名、应用思维链提示、评估模型性能以及保存和加载优化后的模型等步骤。

**重点总结:**

* `BootstrapFewShot`  是一种强大的优化策略，尤其适用于样本数量有限的情况。
* 它通过结合标注样本和引导样本，增强了模型的训练数据，从而提升了模型的整体性能。




## 4.1 Evaluate 模型评估性能工具
### `Evaluate` 类的作用

`Evaluate` 类是 DSPy 框架中用于评估模型性能的工具。它可以帮助你快速评估模型在给定数据集上的表现，并提供相应的评估指标。

### 参数解释

```python
evaluate = Evaluate(devset=devset, metric=simple_metric, num_threads=NUM_THREADS, display_progress=True, display_table=False)
```

1. **`devset`**: 
   - **类型**: 列表或其他可迭代对象
   - **作用**:  用于评估模型性能的验证数据集。每个元素通常是一个字典，包含输入数据和对应的真实标签。
   - **示例**:
     ```python
     devset = [
         {"question": "中国的首都是哪里？", "answer": "北京"},
         {"question": "地球上最大的海洋是什么？", "answer": "太平洋"},
         # ... 其他验证数据
     ]
     ```

2. **`metric`**:
   - **类型**: 函数
   - **作用**: 一个简单的评估指标函数，用于计算模型预测结果的准确率。它通过比较预测结果与真实标签的匹配情况，返回一个表示准确率的浮点数。
   - **示例**:
     ```python

	def simple_metric(predictions, references):
    """计算预测结果与真实标签完全匹配的比例。"""
	    correct_count = sum(p == r for p, r in zip(predictions, references))
	    return correct_count / len(references)

# 示例数据
predictions = ["北京", "乔治·奥威尔", "太平洋", "0度", "梵高"]
references = ["北京", "乔治·奥威尔", "太平洋", "0度", "达芬奇"]

# 计算准确率
accuracy = simple_metric(predictions, references)
print(f"准确率: {accuracy:.2f}")

     ```

3. **`num_threads`**:
   - **类型**: 整数
   - **作用**: 用于评估的线程数。设置多线程可以并行处理数据，从而加速评估过程，特别是在数据集较大时效果更明显。
   - **示例**:
     ```python
     NUM_THREADS = 4  # 使用 4 个线程进行评估
     ```

4. **`display_progress`**:
   - **类型**: 布尔值
   - **作用**: 是否显示评估进度条。如果设置为 `True`，在评估过程中会显示进度条，方便用户了解评估进度。
   - **示例**:
     ```python
     display_progress = True  # 显示评估进度条
     ```

5. **`display_table`**:
   - **类型**: 布尔值
   - **作用**: 是否显示详细的评估结果表格。如果设置为 `True`，评估完成后会显示一个表格，包含每个样本的预测结果、真实标签以及评估指标的计算结果。
   - **示例**:
     ```python
     display_table = False  # 不显示详细的评估结果表格
     ```

### 代码示例

```python
from dspy.evaluate import Evaluate

# ... 定义模型和数据集 ...

# 初始化 Evaluate 对象
evaluate = Evaluate(
    devset=devset, 
    metric=simple_accuracy, 
    num_threads=4, 
    display_progress=True, 
    display_table=False
)

# 使用 Evaluate 对象评估模型性能
results = evaluate(model, devset=devset)

# 打印评估结果
print(results)
```


`Evaluate` 类提供了一种便捷的方式来评估模型在验证集上的性能。通过设置不同的参数，你可以控制评估过程的细节，例如评估指标、线程数、进度显示以及结果展示方式等。





### 评估器的作用
评估器（Evaluator）用于评估模型在特定数据集上的性能。通过设置评估器，可以多次评估模型，观察其在不同参数配置下的表现。

### 代码示例
以下是使用 `Evaluate` 类评估模型的代码示例：

```python
from dspy.evaluate import Evaluate

# 设置评估器，可以多次使用。
evaluate = Evaluate(
    devset=gsm8k_devset,    # 评估数据集
    metric=gsm8k_metric,    # 评估指标
    num_threads=4,          # 使用的线程数
    display_progress=True,  # 是否显示进度
    display_table=0         # 是否显示评估结果表格
)

# 评估 `optimized_cot` 程序。
evaluate(optimized_cot)
```

### 解释
1. **导入 Evaluate 类**：从 `dspy.evaluate` 模块中导入 `Evaluate` 类。
2. **设置评估器**：使用 `Evaluate` 类创建一个评估器实例。参数说明如下：
   - `devset`：用于评估的开发数据集。在本例中，使用的是 `gsm8k_devset`。
   - `metric`：评估指标。在本例中，使用的是 `gsm8k_metric`。
   - `num_threads`：评估时使用的线程数，可以加快评估速度。
   - `display_progress`：是否显示评估进度，设置为 `True` 表示显示。
   - `display_table`：是否显示评估结果表格，设置为 0 表示不显示。
3. **评估模型**：调用评估器的实例 `evaluate`，传入要评估的模型 `optimized_cot`，进行评估。

### 评估结果
评估完成后，评估器将根据指定的评估指标（如 `gsm8k_metric`）计算模型的性能，并输出评估结果。您可以根据这些结果调整和优化模型。

### 总结
评估器在 DSPy 中用于评估模型在特定数据集上的性能，通过设置评估器的参数，可以灵活地评估模型，并根据评估结果进行优化和调整。





